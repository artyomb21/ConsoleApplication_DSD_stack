
/*Практические рименение динамических структур данных STACK(стек)куча(с английского).особенность структуры являетс
его принцип работы с элементами то есть объектами. LAST IN FIRST OUT (LIFO) (последний зашел первым вышел)
для его реализаций нам нужно создать прототип объекта сами объекты будет создоватся с помощю кода Date* p=new Date
но особенность структура данных от вектора отличается в тем что связь с элементами создают указатели в виде полей
и здесь очень важно понимать роль указателей и на этом важном ноте разберем поле класа Date  next_object?то  есть тип
данных на указателей тоже будет Date. Методами для обработки или манипуляций с данными полей будет метод ввода
и вывода данных. и очень важный для нас два метода set_next() get_next() метод
void set_next(Data*next) указатель который является полем принимает адрес следуюшего объекта
Data* get_next() значает возврашает указатель на следующий элемент
прототип наших элементов уже готов и теперь создаем объект в котором будут поле указатель на элементы то есть
на объекты класса Date   // Date* pointer
 и методы создать, показать все, удалить с вершины или удалить по номеру объекта ,то есть  по списку
начнем с создание add() проверяем если нет объектов то, создание объекта с помощю простой команды и связь с ним
обеспечевает указатель с класса My_stack pointer. если уже есть элемент то нам нужно создать новый объект с указателем
t потом указатель поле который является объектом элемента указывает на предедющий то есть старый , предедущий
имеющий объект pointer потом указатель pointer присваивается созданный нами объект то есть , наша структура
имеет такой вид в объекте указатель указывает на элемент то есть объект а сам объект в полях указатель указывает на
следующий элемент ,то есть объект. Новый нами созданный элемент становится в ряд с вершины и удаление так же произойдет
оттудо же , то есть с вершины по принятому принципу полетный пришел первым вышел LIFO, но мы сможем удалить или
добавить туда, куда мы хотим  и у нас есть метод удаление , то есть изятие erase(int a)метод принимает номер удаляемого
элемента давайте разберем код erase(int n),если число элементов 0 то return просто
возврашает функцию не счем если это первый объект то срабатывает наш обычний метод удаление с вершины в иних
случиях создается два указателя один на следуюший элемент после вершины а второй на указатель вершину и с
помощю цыкла указатели две переносятся в правую то есть обратную сторону вершини стека до нужного объекта и
указатель предедущийего удаляемого элемента удазывает на элемента который находится после удаляемого элемента
и в конце удаляется временный указатель t.
*/
#include <iostream>
#include <Windows.h>
using namespace std;
class Data
{
	int x;
	Data* next_object;
public:
	Data() :x(0), next_object(NULL)
	{}
	Data(int x, int y) :x(x)
	{
		next_object = NULL;
	}
	void input_info()
	{
		cout << "input x" << endl;
		cin >> x;
	}
	void set_next(Data* next)
	{
		next_object = next;
	}
	Data* get_next()
	{
		return next_object;
	}
	void show()
	{
		cout << "x = " << x << endl;
	}
};  //next_object указатель является полем 
class My_stack
{
private:
	Data* pointer;
public:
	My_stack() :pointer(NULL) {}
	void add()
	{
		if (pointer == NULL)
		{
			pointer = new Data;//если указатель указывает на объект то не объект . метод а объект стрелочка
		}
		else {
			Data* t = new Data;
			t->set_next(pointer);
			pointer = t;
		}
		pointer->input_info();
	}
	void delete_object()
	{
		Data* t = pointer->get_next();
		delete pointer;
		pointer = t;
	}
	void erase(int n)
	{
		if (n == 0)return;
		else
			if (n == 1)delete_object();
			else
			{
				Data* t = pointer->get_next(), * prev_t = pointer;
				for (int i = 0; i < n - 2; ++i)
				{
					if (t == NULL)
					{
						return;
					}
					prev_t = t;
					t = t->get_next();
				}
				prev_t->set_next(t->get_next());
				delete t;
			}
	}
	void show_objects()
	{
		Data* t = pointer;
		while (t)
		{
			t->show();
			t = t->get_next();
		}
	}
	~My_stack()
	{
		while (pointer)
		{
			delete_object();
		}
	}
};
int main()
{
	//testing
	My_stack object_control;
	object_control.add();
	object_control.add();
	object_control.add();
	object_control.show_objects();
	object_control.erase(1);
	cout << endl << endl;
	object_control.show_objects();
}






